22-Dec-2025

09:36 PM
mfakih
This is the 1st day working on push swap as a team mfakih and mitani.

This paper will document all the needed algorithms and
stategies needed to understand the push_swap project such that
you will be able to reinmplement it in your way.
I will cover the most important algorithms and how to do each one in theory 
which will be different than how you would go about it in code.

I will also use this opportuinity to document my own progress through this
project. Sharing my interpretation of the subject, the ideas i tried, the issues
i faced and how we came to solve it.

Each section will be titled with the date of that day and every subsection will clearly 
demonstrate the next task at hand we are working on.

Understanding the subject:
This is probably the most complicated part of any project, so we must go over it clearly to avoid
any future confusion. This part will also decide most if not all the approaches to go about this project.

11:16 PM
mfakih

After thorough reading of the subject I came to the following conclusions:
1. parsing string inputs to linked lists
2. the linked lists should be double sided why? well ig it can be useful later but we can start with one sided
3. set up proper add and delete functions to this linked  list
4. write the operations neatly
5. test these steps sepeately for leaks using valgrind
6. the algorithms are still work in process but i will attach a chat history of my mental warzones with gpt for reference
7. after all operations are done we need functions that clean up
8. they should free all lists and return a sungle string of operations seperated by \n only

note the chat link: https://chatgpt.com/share/6949b50e-65c0-8001-9032-459da6007e21
Now tmrw is a new day and a new mind to think with for now have a great rest of the night.
i will see you in the morning. Goodnight.

23-dec-2025

05:23 PM
mfakih
To continue on the plan we started yesterday we should define the i/o of this project
The program shall take as input a string of numbers seperated by a space (purely numeric)
the output should be a list of operations seperated by a \n.
There fore we can conclude that we will need a split function to parse the input
and a join function to generate the output format.
we will also need a function to validate the input to be purely a 2d array of numbers

now we can start by the basics probably we will not need all of libft but learning to integrates is a good idea
(espessially learning how to create a makefile that compiles libft and then uses it to compile push_swap)

First we should create the linked list structure.
In our case we will be using the same structure from libft which is why we
added it into the project directory and will be compiling it in the make file 
(check the makefile for more details)

Then we will build the operations in a file operations.c
feel free to use this repository for inspiration but avoid copying codes as that will not be beneficial on the long return
Below i will list each operation, describe its work and explain a structure of which it can be coded.

In order to keep track of norminette we will make sure that we only have 5 functions/file
which is why we will create an operations files described as operations.c 
swap/rotate/rev_rotate.

The 1st file swap_ops.c will include the functions sa sb and ss, such that
sa (swap a): Swap the first two elements at the top of stack a.
Do nothing if there is only one or no elements.
in order to do that we shall 
sb (swap b): Swap the first two elements at the top of stack b.
Do nothing if there is only one or no elements.
ss : sa and sb at the same time

the 2nd file push_ops
pa (push a): Take the first element at the top of b and put it at the top of a.
Do nothing if b is empty.
pb (push b): Take the first element at the top of a and put it at the top of b.
Do nothing if a is empty

the 3rd file
ra (rotate a): Shift up all elements of stack a by one.
The first element becomes the last one.
rb (rotate b): Shift up all elements of stack b by one.
The first element becomes the last one.
rr : ra and rb at the same time.
rra (reverse rotate a): Shift down all elements of stack a by one.
The last element becomes the first one.
rrb (reverse rotate b): Shift down all elements of stack b by one.
The last element becomes the first one.
rrr : rra and rrb at the same time.

now upon further inspection of the operations it is very clear that we only need 4 functions
swap:
swaps the 1st 2 elements of any list
we send it either a or b or we call it twice thus ss

push:
pushes the 1st element from lst 1 to lst 2 so it takes 2 argumens
lst1 lst2 based on the order of sending stack_a stack_b we get pb 
whereas sending the arguments as stack_b stack_a it will act as pa

rotate:
removes the top element of the list to the btm of it

rev_rotate:
removes the last element of the list to its top 

11:55 PM
mfakih
So overall we will have these possible combinations to represent the operations as needed
// Swap operations
// sa : swap top 2 of stack a       -> swap(&stack_a);
// sb : swap top 2 of stack b       -> swap(&stack_b);
// ss : swap top 2 of both stacks   -> swap(&stack_a); swap(&stack_b);

// Push operations
// pa : push top of b to a          -> push(&stack_b, &stack_a);
// pb : push top of a to b          -> push(&stack_a, &stack_b);

// Rotate operations
// ra : shift up all elements of a  -> rotate(&stack_a);
// rb : shift up all elements of b  -> rotate(&stack_b);
// rr : shift up both stacks        -> rotate(&stack_a); rotate(&stack_b);

// Reverse rotate operations
// rra : shift down all elements of a -> rev_rotate(&stack_a);
// rrb : shift down all elements of b -> rev_rotate(&stack_b);
// rrr : shift down both stacks        -> rev_rotate(&stack_a); rev_rotate(&stack_b);

01:55 AM 
mfakih
After some break time, it is time now to get back to the project and work on input parsing
we shall decide the type of input we want to accept
the flags  that would guide the excusion
and deinfe any and all cases that would lead to an error.
In standard language for now our input will be a string of unique numbers
then we can also have a flag indicator that will be passed before the nb inputs to guide the program excution
possible flags are as follows:
THE PROGRAM SHOULD ALWAYS OUTPUT TO STDOUT THE LIST OF OPERATIONS SEPERATED BY /n


THE POSSIBILITY OF A BENCH flag
in case the --bench flag was sent it will be the 1st arg and in this case only we output to the STDERR the following benchmarks
The computed disorder (% with two decimals).
◦ The name of the strategy used and its theoretical complexity class.
◦ The total number of operations.
◦ The count of each operation type (sa, sb, ss, pa, pb, ra, rb, rr, rra, rrb,
rrr).
The benchmark output must be sent to stderr and only appear when the flag is
present
To send output to stderr remember that you can send that as a flag to the function write(fd, context, bytes)
As a refresher fd=0 stdin
               fd=1 stdout
               fd=2 stderr
so in this case all you gotta do is create a print function and send it fd=2


THE PROGRAM SHOULD ALWAYS OUTPUT THE LIST OF OPERATIONS SEPERATED BY /n
THE CHOSEN ALGORITHM DEPENDS ON THE 2ND FLAG IF AVAILABLE (argc > 3)
1. --simple
    uses the complexity O(n squared)
2. --medium
    uses the complexity O(n radical n)
3. --complex 
    uses the complexity O(nlogn)
4. --adaptive
    chooses the best complexity based on the degree of distortion
5. if no flags are passed then it is considered to be adaptive.

the flags are usually argv[1] if none are present then we assume the input is only the string 

PARSING THE numbers
there are more than one possibility to how far we want to go in terms of the accepted inputs.
cases include but are not limited to:
"1 2 3 4"
"1" "2" "3" "4"
1 "2" "3" 4

therefore the choice of what accepted data is going to greately affect how we go about the code.
for starers we will only accept input as a full string where all nbs are strictly seperated by white spaces (including + or - signs is accepted)
adding extra layers of parsing is very time consuming therefore at this state we will not be exploring that operation

In short we might have up to argc = 4

if argc == 1
this has to be the input list
complexity is considered by default adaptice
bench is considered by default to be faulse

if argc == 2
we check the 1st argument to be either bench or the complexity
the 2nd argiment is to be parsed to be the number and anything else will be considered invalid resulting in an error

if argc == 3
we check the 1st arg to be bench strictly anything else is considred invalid
we check the 2nd arg to be the complexity level anything else will be considerd invalid
the 3rd argument is to be the nbr list to be parsed

IN ALL THESE CASES ANY ERRORS IN PARSING THE NBS
OR ANY EXPECTED ARGUMENTS WILL LEAD TO ERROR THUS TERMINATING THE PROGRAM
dev note: make sure to free everything in case of error.
duplicated inputs is also considered an error.

argv[1] = program name


24-dec-2025

09:42 PM
mfakih

After some thoughts, we discovered that it is better to parse the input in a slightly different way to make it stricter and avoid ambiguous cases. The plan is as follows:

Input Parsing Strategy:

Initialize index and flags
Start traversing argv at index i = 1.
Initialize a boolean bench as false.
Initialize a string strategy as null.
Check for --bench flag
If argv[i] equals --bench, set bench to true and increment i.
If not, leave i as 1.
Check for strategy flag
If argv[i] matches one of the strategy flags (--simple, --medium, --complex, --adaptive), save it in strategy and increment i.
If not, leave i unchanged.
If an unknown flag is found, print Error\n to standard error and terminate.
Collect the numbers
From argv[i] to the last argument, join all arguments into a single string.
This string should contain only numbers, optional + or - signs, and spaces.
Any invalid character or malformed sign sequences should result in an error.
Validate the number string
Ensure that no + or - appears without a digit following it.
Ensure that there are no multiple consecutive signs in front of a number.
Ensure that only numeric characters, spaces, and single signs are present.
If validation fails, free any allocated memory, print Error\n to standard error, and terminate.
Split and check for duplicates
Split the validated string into an array of strings using whitespace as a separator.
Check the resulting array for duplicates
If duplicates exist, free all memory, print Error\n to standard error, and terminate.
Convert to linked list
Convert each string in the array to an integer.
Add each integer to the linked list representing stack_a, with the first element as the top of the stack.
Free the array of strings after conversion.
Error handling and cleanup
At every step, memory allocated for flags, concatenated strings, arrays, or linked list nodes must be freed in case of an error.
Only proceed to generating operations if all checks pass.


Rationale:

Restricting flags to the start prevents ambiguous input, such as flags appearing in the middle of the number list.
Handles negative numbers correctly.
Prevents malformed inputs like 1 2 - 5 or multiple signs.
--bench output is sent to standard error, while operations always go to standard output.
Keeps parsing deterministic and aligned with the subject’s requirements.


Summary Logic Flow:

Start at argv[1]
Detect --bench → set boolean, increment index
Detect strategy flag → save, increment index
Join remaining arguments → validate string
Validate numbers and signs
Split string → check duplicates
Convert to integers → populate linked list
Free temporary memory → ready for operations
But how would we excute all these edge cases checks in code well.
Edge Cases and Pre-Split Validation
After reviewing possible malformed inputs, we decided that some checks must be done before splitting the
concatenated input string, because splitting blindly could allow invalid sequences to go unnoticed. The checks are as follows:
Detect isolated signs
An isolated + or - that does not precede a number should be considered invalid.

Example: "1 2 - 5" → the - here is standalone → invalid.
This is because atoi or similar conversion functions would misinterpret or fail on such cases.
The detection function will scan the string from start to end:
Skip spaces.
If a + or - is found, check that the next character is a digit.
If it is not a digit, return an error.
Detect multiple consecutive signs
Multiple signs before a number, such as ++3 or --5, are invalid.
The function will iterate through the string and count consecutive signs:
If more than one sign appears consecutively without a number between, return an error.
Detect signs separated by spaces
A sign separated by spaces from its number is invalid.
Example: "1 2 - 3" → invalid because - is not attached directly to 3.
The function will check that any + or - is immediately followed by digits, with no intervening spaces.
Detect invalid characters
Only digits, spaces, and one optional + or - per number are allowed.
Any other character (a-z, punctuation other than +/-, etc.) triggers an error.
Structure of the Pre-Split Validation Function
Single function will take the concatenated input string as input.
Iterates character by character.
Maintains a simple state:
Are we at a digit sequence?
Did we just see a sign?
Returns true if the string passes all checks.
Returns false and triggers cleanup if any rule is broken.
This function ensures that by the time we reach the split stage, every segment is a valid number and no malformed signs remain.
This reduces downstream errors and simplifies memory management.
Integration with the Main Parsing Flow
After detecting flags and collecting the number string:
Run the pre-split validation function.
If it fails → free any allocated memory (flags, strings), print Error\n to stderr, terminate.
If it passes → proceed to split, duplicate check, and linked list conversion.
This way, all malformed inputs related to signs or spaces are caught early,
and the split function can safely assume every token is a valid number. The approach guarantees stricter,
predictable parsing that aligns with the 42 push_swap subject.

25-dec-2025

02:33 AM
mfakih
Hey again, i finished a big chunk of the parsing described above
hopefully my implementation has no leaks but if so we will test for that tmrw
the next parts include splitting checking duplicates if so free everything
else parse into linked list w from there we are done with the leaks part
nshala tdal norminette in check
w hopefully the short looking implementation doesnt have a million leaks to debug
i will test it tmrw after i finish the splitting part and stress test for leaks aw ana aw interpretation
see yall when my brain is in better conditions
gn

12:54
mfakih

Hello again, and merry christmas!
Today we will be testing the parsing logic we did yesterday for any memory leaks
I will keep you guys updated on any issues we face and possible solutions
check the file pushswap.c and utils.c to check the parsing logic
i will probably move them to a file parsing.c soon 

02:40 PM
mfakih
updated the parsing logic it was mainly great but had a few issues with dereferencing the pointers
which led to seg faults but other than that we had minor fixes of memory leaks which is only freeing the complecity char * in case of error
i also changed the function ft_strjoin_sep to be more readable and better overall :)

i did indeed move the parsing logic to their seperae file and created a helper funtion for the main to make sure we wont get into any norm issues in the near future
the last part to check in parsing now is to split the string of inputs and check for duplicates
to be done in the next commit

02:47 PM
mfakih

im back again i thought of a testcase where we wont notice an issue in parsing and that is if the last char was a letter or anything 0_0
well that is l2n we are only checking it to be not + or  - instead we should check it to be isnumeric or space 
here is a code snippet tto save you time of searching for it 


int	parse_input(int *i, char **argv, char **nbs)
{
	int		j;
	char	*s;

	j = -1;
	while (argv[*i])
	{
		ft_strjoin_sep(nbs, argv[*i], " ");
		if (!*nbs)
			return (-1);
		(*i)++;
	}
	s = *nbs;
	while (s[++j])
	{
		if (s[j] != ' ' && s[j] != '+' && s[j] != '-'
			&& !ft_isdigit(s[j]))
			return (free(s), -1);
		if ((j > 0)
			&& (s[j] == '-' || s[j] == '+')
			&& ((s[j - 1] != ' ') || (!ft_isdigit(s[j + 1]))))
			return (free(s), -1);
	}
    //THE ISSUE WAS HEREEEEEEEEEEE
	if ((s[j] == 0) && (s[j - 1] == ' ' || !ft_isdigit(s[j - 1])))
		return (free(s), -1);
	return (0);
}

okay now if yoou run this test note that you will have this mid production stats printed twice
this is totally normal l2n we have umm we are calling the funtion validate_input twice bel main 
eh sa7 w even though they are in if elseif statements you are still calling it w inside that function you are printing studd
to fix that we can just add a variable in the main like maybe call it umm alls_valid or smthn i will add that later now i need a break of seg faults and leaks :)


25-dec-2025

05:17 PM
mfakih
okay for this update we added the last part of the validations that is checking for duplicates
now we only have to parse the 2d array we have of nbs into an actual linked list and use atoi to convert them to int
so that we can perform compare functions on them easily now :)
all leaks were managed in this update 


12:06 AM
mfakih
hey again guys, i went down a rabbit hole to figure out this final version i implemented of the check flags function.
it now allows me to pass the flags in any order --bench --complexity or vice versa
and thank god i do not remember all the things i tried l2n they were insanely complicated al fadi
this is great for now 
tmrws plan anu to create a new atoi function that is exactlyy like atoi
except it checks if int is now > max int or < min int it will set a flag that is special abt this new version
the flag is overflow bit and it is passed by reference 
w laa akid its not just one bit in size its just an int haha take
we put this flag let it live inside my parse_to_linked_list function and in case at any time this flag is now 1 not zero
we clear the wholeee list
then we return null w bi l validate function we will update it

essa it returns int bs soon it will start returning a linked list 
this we will keep bel main w use to do all our operations on yesterday

halaa fi shi ba3d one of my friends bought to my attention i should fix this asapp
anu if we compare +100 w 100 these are duplicates :(((
man i wana sleppppp
yala tmrw we will figure these out aw 
WORSE CASE SENARIO? ILL JUST NOT ALLOW + SIGNS ANYMORE HEHE
yal gn se yall tmrw nshala ysir 3ena shi metl l 3elam w l khal2 :)


27-dec-2025

05:44 PM
mfakih
mitani will now change the function validate to return a linked list that will be the main thing the main has to receive
in case of any errors the validate function should now return NULL instead of the -1 flag it used to return as an int function

the check duplicates function is checking now on strings so the issue of +100 vs 100 or any equivelent is still persisten
so we need to delete that function and remake it into a check duplicates function that compares linked lists

to avoidd havin extra functions we can directly compare them while we are building the list
using some simple ducplicate checking loop 
in case of any dups we should use the function ft_lstclear to free everything and thus return null 

in case of a null list the main program will terminate

we check the distortion 1st in main and then if disorder ==0  also return the solution as no moves
else cal the function w now you send this function 
else we will call a funtion that takes this list and bench and complexity and distortion to then sort the list


28-dec-2025

03:18 PM
mfakih

Done with the parsing and checked everything for memory leaks and conditional jumps
all is great!!
i will next work on the algoritms seperately and nicely

well we still have to do the function that checks the disorder but these are simple

29-dec-2025

07:27 PM
mfakih

well, the last commit was horrible in every way i can think of nothing runs but hey! we have no leaks gahahah but the output is all over the place
so now i will be working on it to try and figure out what the issue is so that i can get back to you with better updates

i will start with decentralizing the stack_b by putting it in main w what is the issue with the fact that my stack b was never initialized?
halaa sara7a how should i initialize it just malloc one empty place? make the content poin to null? w l next null? bsir when i push to b bghayer l content
well idk let me think and get back 
see yal



10:43 PM
mfakih

todays update is as unique as it can ever be,
and an important reminder to prioritize rest since with no breaks you will just be wasting time working tried
and yesterdays update was living proof of it

yes i did laly down the main structure but i had small mistakes that made the whole thing hard to debug
the nb 1 issue akid was norminettte but that is nothing

the 1st error i noticed which was causing all the conditional jumps is that i had 
NOT INITIALIZED THE STRING THAT WILL HOLD THE OUTPUT!!
that my friends scores nb one on how dumb i can be when im sleepy haha
so that took a while to notice fixing it was quite simple (i was looking for worse errors when that stupid little thing missed me)

the 2dn issue was that the array was now getting sorted bs i had leaks well obv if i fogot to init that output string i also forgot to free it so theres that

3rd issue now the list was being not being sorted but all so weirdly
an example that made me notice the issue is the following
kindly note that i have not added the part where we calculate disorder yet since these basic cases are helping me debug :)
./push_swap 1 2 3 4
pb
rra
rra
rra
pb
rra
rra
pb
ra
pb

this was the output i was getting well very obviously
I FORGOT TO PUSH BACK ALL THE DATA TO STACK A 

so i did add the while loop of 4 lines that is now its seperate function
called push_back_to_a to remind myself of this missed part 

now the array at this point is being sorted but weirdly adding extra rotations
which it shouldnt l2n i am comparing the index right
wronggg
awal shi l2n i wasnt updating the current inside the while loop i was updating it awal shi
then only after the rotations
and that was obvious in the example above well since it was doing all these rra 
when the min was at the top

so the issue is obviously the indexing and so one look at the find min function
and oh no
it does find min
but what is it returning
it returns the list len in the was it was written

so i added a new variable to track position and updated the (*index) only when i found min

now it worked!!

then i tried an input that wasnt sorted the following 
1 2 4 3 simple eh? 
i expected the perfect output only rotate once the shortest direction

but i got 3 rra rra rra 
and here i noticed the last bug!
the <> signs i used bel main do not reflect how the rotate functions work 
again how basic can that be of an error

so now we had it all done
fixed all norm errors
and now i will sleep so that i dont code another mess to debug tmrw haha

rest well,
and Goodnight!!


11:44 PM 
mfakih 

hey i had to give you a stats log before i sleep so here is a nice table of the tested values 

for simple algorithms
+----------------------------+-----------+-----------------+
|        Input Type          | # Numbers | # Operations    |
+----------------------------+-----------+-----------------+
| Random shuffled 100        | 100       | 1776            |
| Slightly shuffled 100      | 100       | 298             |
| Random shuffled 100        | 100       | 1776            |
| Alternating pairs 100      | 100       | 1492            |
| Random shuffled 100        | 100       | 1545            |
| Random shuffled 500        | 500       | 32581           |
| Random shuffled 500        | 500       | 33398           |
+----------------------------+-----------+-----------------+

yal byee


30-dec-2025
05:57

mfakih

today i fixed the complex algorithm updated by mitani yesterday
the logic was all great applying radix sort clearly but it did not handle the possibility that the input might be -versa

well why would that affect sorting you might say so here goes

how does radix sort work, it is a good idea to chnck data not on its physical values
but rather by its main constituents

for example a simple sort would search for a min so it will need aprox n rotations and n pushes
so O n squared

a chuncking algorithm will find all elements less than radical n into a bucket
thus it wont need n rotations to find a number it would need radical n rotations which is a huge simplification
for n = 100 we will need at most 10 rotations instead of 100 for an unoptimized alg or 50 (considering like ours it rotates the shorter direction)

No matter how large the number is, or how many numbers we have,
all integers have 32 bits.

So instead of comparing values directly, we can sort bit by bit.

For example, let’s say we have these numbers written in binary:

110
111
001


This is how radix sort (LSD – least significant bit first) works.

Step 1 — Least significant bit (bit 0)

Look at the rightmost bit:

110 → 0
111 → 1
001 → 1


Rule:

push 0 bits to stack B

keep 1 bits in stack A

preserve order (this is important)

After pushing 0s to B:

A: 111 001
B: 110


Push B back to A:

A: 110 111 001

Step 2 — Second least significant bit (bit 1)

Check the second bit from the right:

110 → 1
111 → 1
001 → 0


Push 0s to B:

A: 110 111
B: 001


Push B back to A:

A: 001 110 111

Step 3 — Third least significant bit (bit 2)

Check the third bit:

001 → 0
110 → 1
111 → 1


Push 0s to B:

A: 110 111
B: 001


Push back:

A: 001 110 111

Final result
001
110
111

Sorted correctly.


now the issue with this bit sorting style is that negative numbers mess it up

which is why i added the extra workflow under the main idea ranking in the file complex.c 
these functions work on the existing stack_a and copy it into a side array
sort that array
then use the indexing of that array to replace each value in the linked list with its +ve representative nb
or in other words ranking it
we could have changed the linked list structure to accept a content and rank
but that would complicate the other parts and would cause adjustments on libft so to avoid that we just changed the actual content
and that does not conflict with the subject which mentions that we only care about the output being the operations not the content
so all is still good!!

31 dec
06:51 PM
mfakih

i added the functions that calculate the disorder and chooses the correct algorithm based on that
if the flag was adaptive or forces an alg based on the passed flags
anyway we still have to print the benchmark and do the medium algorithm

