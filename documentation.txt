22-Dec-2025

09:36 PM
mfakih
This is the 1st day working on push swap as a team mfakih and mitani.

This paper will document all the needed algorithms and
stategies needed to understand the push_swap project such that
you will be able to reinmplement it in your way.
I will cover the most important algorithms and how to do each one in theory 
which will be different than how you would go about it in code.

I will also use this opportuinity to document my own progress through this
project. Sharing my interpretation of the subject, the ideas i tried, the issues
i faced and how we came to solve it.

Each section will be titled with the date of that day and every subsection will clearly 
demonstrate the next task at hand we are working on.

Understanding the subject:
This is probably the most complicated part of any project, so we must go over it clearly to avoid
any future confusion. This part will also decide most if not all the approaches to go about this project.

11:16 PM
mfakih

After thorough reading of the subject I came to the following conclusions:
1. parsing string inputs to linked lists
2. the linked lists should be double sided why? well ig it can be useful later but we can start with one sided
3. set up proper add and delete functions to this linked  list
4. write the operations neatly
5. test these steps sepeately for leaks using valgrind
6. the algorithms are still work in process but i will attach a chat history of my mental warzones with gpt for reference
7. after all operations are done we need functions that clean up
8. they should free all lists and return a sungle string of operations seperated by \n only

note the chat link: https://chatgpt.com/share/6949b50e-65c0-8001-9032-459da6007e21
Now tmrw is a new day and a new mind to think with for now have a great rest of the night.
i will see you in the morning. Goodnight.

23-dec-2025

05:23 PM
mfakih
To continue on the plan we started yesterday we should define the i/o of this project
The program shall take as input a string of numbers seperated by a space (purely numeric)
the output should be a list of operations seperated by a \n.
There fore we can conclude that we will need a split function to parse the input
and a join function to generate the output format.
we will also need a function to validate the input to be purely a 2d array of numbers

now we can start by the basics probably we will not need all of libft but learning to integrates is a good idea
(espessially learning how to create a makefile that compiles libft and then uses it to compile push_swap)

First we should create the linked list structure.
In our case we will be using the same structure from libft which is why we
added it into the project directory and will be compiling it in the make file 
(check the makefile for more details)

Then we will build the operations in a file operations.c
feel free to use this repository for inspiration but avoid copying codes as that will not be beneficial on the long return
Below i will list each operation, describe its work and explain a structure of which it can be coded.

In order to keep track of norminette we will make sure that we only have 5 functions/file
which is why we will create an operations files described as operations.c 
swap/rotate/rev_rotate.

The 1st file swap_ops.c will include the functions sa sb and ss, such that
sa (swap a): Swap the first two elements at the top of stack a.
Do nothing if there is only one or no elements.
in order to do that we shall 
sb (swap b): Swap the first two elements at the top of stack b.
Do nothing if there is only one or no elements.
ss : sa and sb at the same time

the 2nd file push_ops
pa (push a): Take the first element at the top of b and put it at the top of a.
Do nothing if b is empty.
pb (push b): Take the first element at the top of a and put it at the top of b.
Do nothing if a is empty

the 3rd file
ra (rotate a): Shift up all elements of stack a by one.
The first element becomes the last one.
rb (rotate b): Shift up all elements of stack b by one.
The first element becomes the last one.
rr : ra and rb at the same time.
rra (reverse rotate a): Shift down all elements of stack a by one.
The last element becomes the first one.
rrb (reverse rotate b): Shift down all elements of stack b by one.
The last element becomes the first one.
rrr : rra and rrb at the same time.

now upon further inspection of the operations it is very clear that we only need 4 functions
swap:
swaps the 1st 2 elements of any list
we send it either a or b or we call it twice thus ss

push:
pushes the 1st element from lst 1 to lst 2 so it takes 2 argumens
lst1 lst2 based on the order of sending stack_a stack_b we get pb 
whereas sending the arguments as stack_b stack_a it will act as pa

rotate:
removes the top element of the list to the btm of it

rev_rotate:
removes the last element of the list to its top 

11:55 PM
mfakih
So overall we will have these possible combinations to represent the operations as needed
// Swap operations
// sa : swap top 2 of stack a       -> swap(&stack_a);
// sb : swap top 2 of stack b       -> swap(&stack_b);
// ss : swap top 2 of both stacks   -> swap(&stack_a); swap(&stack_b);

// Push operations
// pa : push top of b to a          -> push(&stack_b, &stack_a);
// pb : push top of a to b          -> push(&stack_a, &stack_b);

// Rotate operations
// ra : shift up all elements of a  -> rotate(&stack_a);
// rb : shift up all elements of b  -> rotate(&stack_b);
// rr : shift up both stacks        -> rotate(&stack_a); rotate(&stack_b);

// Reverse rotate operations
// rra : shift down all elements of a -> rev_rotate(&stack_a);
// rrb : shift down all elements of b -> rev_rotate(&stack_b);
// rrr : shift down both stacks        -> rev_rotate(&stack_a); rev_rotate(&stack_b);

01:55 AM 
mfakih
After some break time, it is time now to get back to the project and work on input parsing
we shall decide the type of input we want to accept
the flags  that would guide the excusion
and deinfe any and all cases that would lead to an error.
In standard language for now our input will be a string of unique numbers
then we can also have a flag indicator that will be passed before the nb inputs to guide the program excution
possible flags are as follows:
THE PROGRAM SHOULD ALWAYS OUTPUT TO STDOUT THE LIST OF OPERATIONS SEPERATED BY /n


THE POSSIBILITY OF A BENCH flag
in case the --bench flag was sent it will be the 1st arg and in this case only we output to the STDERR the following benchmarks
The computed disorder (% with two decimals).
◦ The name of the strategy used and its theoretical complexity class.
◦ The total number of operations.
◦ The count of each operation type (sa, sb, ss, pa, pb, ra, rb, rr, rra, rrb,
rrr).
The benchmark output must be sent to stderr and only appear when the flag is
present
To send output to stderr remember that you can send that as a flag to the function write(fd, context, bytes)
As a refresher fd=0 stdin
               fd=1 stdout
               fd=2 stderr
so in this case all you gotta do is create a print function and send it fd=2


THE PROGRAM SHOULD ALWAYS OUTPUT THE LIST OF OPERATIONS SEPERATED BY /n
THE CHOSEN ALGORITHM DEPENDS ON THE 2ND FLAG IF AVAILABLE (argc > 3)
1. --simple
    uses the complexity O(n squared)
2. --medium
    uses the complexity O(n radical n)
3. --complex 
    uses the complexity O(nlogn)
4. --adaptive
    chooses the best complexity based on the degree of distortion
5. if no flags are passed then it is considered to be adaptive.

the flags are usually argv[1] if none are present then we assume the input is only the string 

PARSING THE numbers
there are more than one possibility to how far we want to go in terms of the accepted inputs.
cases include but are not limited to:
"1 2 3 4"
"1" "2" "3" "4"
1 "2" "3" 4

therefore the choice of what accepted data is going to greately affect how we go about the code.
for starers we will only accept input as a full string where all nbs are strictly seperated by white spaces (including + or - signs is accepted)
adding extra layers of parsing is very time consuming therefore at this state we will not be exploring that operation

In short we might have up to argc = 4

if argc == 1
this has to be the input list
complexity is considered by default adaptice
bench is considered by default to be faulse

if argc == 2
we check the 1st argument to be either bench or the complexity
the 2nd argiment is to be parsed to be the number and anything else will be considered invalid resulting in an error

if argc == 3
we check the 1st arg to be bench strictly anything else is considred invalid
we check the 2nd arg to be the complexity level anything else will be considerd invalid
the 3rd argument is to be the nbr list to be parsed

IN ALL THESE CASES ANY ERRORS IN PARSING THE NBS
OR ANY EXPECTED ARGUMENTS WILL LEAD TO ERROR THUS TERMINATING THE PROGRAM
dev note: make sure to free everything in case of error.
duplicated inputs is also considered an error.

argv[1] = program name